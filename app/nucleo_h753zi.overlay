#include <zephyr/dt-bindings/timer/stm32-timer.h>
#include <zephyr/dt-bindings/pwm/pwm.h>
#include <dt-bindings/pwm/stm32-mcpwm.h>

/ {
	aliases {
		encoder1 = &aeat9955;
	};
};

&dmamux1 {
	status = "okay";
};

&dma1 {
	status = "okay";
};

&dma2 {
	status = "okay";
};

&spi3 {
	status = "okay";
	fifo-enable;

	pinctrl-0 = <&spi3_sck_pb3 &spi3_miso_pb4 &spi3_mosi_pb5 &spi3_nss_pa15>;
	// cs-gpios = <&gpioa 15 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
	pinctrl-names = "default";

	mt6835: mt6835@0 {
		compatible = "magntek,mt6835";
		reg = <0>;
		spi-max-frequency = <DT_FREQ_M(12)>;
		cal-en-gpios = <&gpiog 13 GPIO_ACTIVE_HIGH>;
		status = "okay";
	};
	aeat9955: aeat9955@1 {
		compatible = "brcm,aeat-9955";
		reg = <1>;
		spi-max-frequency = <DT_FREQ_M(4)>;
		status = "okay";
	};
};

// TIM1 is master for TIM3 and TIM8 synchronization
&timers1 {
	compatible = "rubus,stm32-timers";
	st,prescaler = <0>;
	status = "okay";
	st,countermode = <STM32_TIM_COUNTERMODE_CENTER_UP_DOWN>;
	st,master-mode;
	st,master-mode-selection = <0x10>; // LL_TIM_TRGO_ENABLE - sync TIM3 and TIM8

	pwm1:mcpwm {
		compatible = "st,stm32-mcpwm";
		pinctrl-0 = <&tim1_ch1_pa8 &tim1_ch2_pa9 &tim1_ch4_pe14>;
		pinctrl-names = "default";
		period = <PWM_KHZ(20)>;
		status = "okay";
		st,cc-dma-channels = <4>;
		#pwm-cells = <2>;
	};
};

// TIM3 is slave of TIM1
&timers3 {
	compatible = "rubus,stm32-timers";
	st,prescaler = <0>;
	status = "okay";
	st,countermode = <STM32_TIM_COUNTERMODE_UP>;
	st,slave-mode;
	st,slave-mode-selection = <0x6>; // LL_TIM_SLAVEMODE_TRIGGER
	st,trigger-selection = <0x00>; // ITR0 = TIM1

	pwm3:mcpwm {
		compatible = "st,stm32-mcpwm";
		pinctrl-0 = <&tim3_ch1_pc6>;
		pinctrl-names = "default";
		period = <PWM_KHZ(20)>;
		status = "okay";
		#pwm-cells = <2>;
	};
};

// TIM8 is slave of TIM1
&timers8 {
	compatible = "rubus,stm32-timers";
	st,prescaler = <0>;
	status = "okay";
	st,countermode = <STM32_TIM_COUNTERMODE_CENTER_UP_DOWN>;
	st,slave-mode;
	st,slave-mode-selection = <0x6>; // LL_TIM_SLAVEMODE_TRIGGER
	st,trigger-selection = <0x00>; // ITR0 = TIM1

	pwm8:mcpwm {
		compatible = "st,stm32-mcpwm";
		pinctrl-0 = <&tim8_ch1_pc6 &tim8_ch2_pc7>;
		pinctrl-names = "default";
		period = <PWM_KHZ(20)>;
		status = "okay";
		#pwm-cells = <2>;
	};
};

// &pinctrl {
//     tim1_bkin_pe15: tim1_bkin_pe15 {
//         bias-pull-up;
//     };
// 	tim8_bkin_pi4: tim8_bkin_pi4 {
// 		bias-pull-up;
// 	};
// };

&adc1 {
	compatible = "st,stm32-adc-injected";
	pinctrl-0 = <&adc1_inp15_pa3 &adc1_inp11_pc1 &adc1_inp10_pc0 >;
	pinctrl-names = "default";
	st,adc-clock-source = "SYNC";
	st,adc-prescaler = <4>;
	status = "okay";

	st,adc-trigger-source = "tim1_cc4";

	// vref-mv = <3000>;

	#address-cells = <1>;
	#size-cells = <0>;

	channel@3 {
		reg = <3>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,resolution = <16>;
	};

	channel@C {
		reg = <12>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,resolution = <16>;
	};

	channel@A {
		reg = <10>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,resolution = <16>;
	};
};

/ {
		/* Current sampler config, ADC channels */
	/* FIXME: Add drv8328 driver */
	/* drv8328 needs function to wiggle SLEEP to reset an error */
	// Need to configure ADC trigger LL_TIM_CC_EnableChannel(config->timer, LL_TIM_CHANNEL_4)
	control {
		// ADC for current (A, B), bus voltage
		// adc-channels = <&adc1 0>,
		// 	<&adc1 1>,
		// 	<&adc1 5>;
		// current-sense-resistor-uohms = <10000>;
		// current-sense-gain = <50>;
		// phase-inductance-uh = <3400>;
		// phase-resistance-mohms = <5600>;

		current-sense-resistor-uohms = <10000>;
		current-sense-gain = <50>;
		phase-inductance-uh = <3000>;
		phase-resistance-mohms = <1600>;

		pwms = <&pwm1 4 (PWM_POLARITY_NORMAL | STM32_PWM_OC_MODE_PWM2)>;
		amp1 {
			compatible = "ti,drv8328";

			/* If FAULT interrupt is used instead of BRKIN */
			/* Fault interrupt should turn off PWM */
			// fault-gpios = <&gpioi 4 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;

			// sleep-gpios = <&gpiog 14 GPIO_ACTIVE_HIGH>;

			pwms = <&pwm1 1 PWM_POLARITY_NORMAL>,
				   <&pwm1 2 PWM_POLARITY_NORMAL>;
		};

		amp2 {
			compatible = "ti,drv8328";

			/* If FAULT interrupt is used instead of BRKIN */
			// fault-gpios = <&gpiob 15 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;

			// sleep-gpios = <&gpiod 8 GPIO_ACTIVE_HIGH>;

			pwms = <&pwm8 1 PWM_POLARITY_NORMAL>,
				   <&pwm8 2 PWM_POLARITY_NORMAL>;
		};
	};
};