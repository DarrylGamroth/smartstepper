/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/dt-bindings/dma/stm32_dma.h>

// / {
// 		/* Current sampler config, ADC channels */
// 	/* FIXME: Add drv8328 driver */
// 	/* drv8328 needs function to wiggle SLEEP to reset an error */
// 	// Need to configure ADC trigger LL_TIM_CC_EnableChannel(config->timer, LL_TIM_CHANNEL_4)
// 	control {
// 		// ADC for current (A, B), bus voltage
// 		// adc-channels = <&adc1 0>,
// 		// 	<&adc1 1>,
// 		// 	<&adc1 5>;
// 		// current-sense-resistor-uohms = <10000>;
// 		// current-sense-gain = <50>;
// 		// phase-inductance-uh = <3400>;
// 		// phase-resistance-mohms = <5600>;

// 		current-sense-resistor-uohms = <10000>;
// 		current-sense-gain = <50>;
// 		d-phase-inductance-uh = <3000>;
// 		q-phase-inductance-uh = <3000>;
// 		phase-resistance-mohms = <1600>;

// 		pwms = <&pwm1 4 (PWM_POLARITY_NORMAL | STM32_PWM_OC_MODE_PWM2)>;
// 		amp1 {
// 			compatible = "ti,drv8328";

// 			/* If FAULT interrupt is used instead of BRKIN */
// 			/* Fault interrupt should turn off PWM */
// 			// fault-gpios = <&gpioi 4 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;

// 			sleep-gpios = <&gpiog 14 GPIO_ACTIVE_HIGH>;

// 			pwms = <&pwm1 1 PWM_POLARITY_NORMAL>,
// 				   <&pwm1 2 PWM_POLARITY_NORMAL>;
// 		};

// 		amp2 {
// 			compatible = "ti,drv8328";

// 			/* If FAULT interrupt is used instead of BRKIN */
// 			// fault-gpios = <&gpiob 15 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;

// 			sleep-gpios = <&gpiod 8 GPIO_ACTIVE_HIGH>;

// 			pwms = <&pwm8 1 PWM_POLARITY_NORMAL>,
// 				   <&pwm8 2 PWM_POLARITY_NORMAL>;
// 		};
// 	};
// };


/ {
	model = "Smart Stepper Controller";
	compatible = "rubus,smartstepper";

	aliases {
		encoder1 = &aeat9955;
	};
};

&spi2 {
	status = "okay";

	// dmas = <&dma2 4 6 STM32_DMA_PERIPH_TX STM32_DMA_FIFO_FULL>,
	// 	   <&dma1 3 0 STM32_DMA_PERIPH_RX STM32_DMA_FIFO_FULL>;
	// dma-names = "tx", "rx";
};

&spi3 {
	status = "okay";

	// dmas = <&dmamux1 2 15 (STM32_DMA_PERIPH_TX | STM32_DMA_MEM_8BITS)>,
	// 	   <&dmamux1 3 14 (STM32_DMA_PERIPH_RX | STM32_DMA_MEM_8BITS)>;

	// dma-names = "tx", "rx";

	aeat9955: aeat9955@0 {
		compatible = "brcm,aeat-9955";
		reg = <0>;
		spi-max-frequency = <DT_FREQ_M(4)>;
		status = "okay";
	};
};

// Timer 2 is used for input capture of clock generator and photo-interrupter
// &timers2 {
// 	compatible = "rubus,stm32-timers";
// 	st,prescaler = <0>;
// 	status = "okay";
// 	st,master-mode;
// 	st,countermode = <STM32_TIM_COUNTERMODE_UP>;

// 	triggers: triggers {
// 		compatible = "st,stm32-timer-ic";
// 		pinctrl-0 = <&tim2_ch1_pa0 &tim2_ch2_pb3>;
// 		pinctrl-names = "default";
// 		status = "okay";
// 	};
// };

// TIM1 is master for TIM3 and TIM8 synchronization
&timers1 {
	compatible = "rubus,stm32-timers";
	st,prescaler = <0>;
	status = "okay";
	st,countermode = <STM32_TIM_COUNTERMODE_CENTER_UP_DOWN>;
	st,master-mode;
	st,master-mode-selection = <0x10>; // LL_TIM_TRGO_ENABLE - sync TIM3 and TIM8

	pwm1:mcpwm {
		period = <PWM_KHZ(20)>;
		st,cc-dma-channels = <4>;
		status = "okay";
		#pwm-cells = <2>;
	};
};

// TIM3 is slave of TIM1
&timers3 {
	compatible = "rubus,stm32-timers";
	st,prescaler = <0>;
	status = "okay";
	st,countermode = <STM32_TIM_COUNTERMODE_UP>;
	st,slave-mode;
	st,slave-mode-selection = <0x6>; // LL_TIM_SLAVEMODE_TRIGGER
	st,trigger-selection = <0x00>; // ITR0 = TIM1

	pwm3:mcpwm {
		compatible = "st,stm32-mcpwm";
		period = <PWM_KHZ(20)>;
		status = "okay";
		#pwm-cells = <2>;
	};
};

// TIM8 is slave of TIM1
&timers8 {
	compatible = "rubus,stm32-timers";
	st,prescaler = <0>;
	status = "okay";
	st,countermode = <STM32_TIM_COUNTERMODE_CENTER_UP_DOWN>;
	st,slave-mode;
	st,slave-mode-selection = <0x6>; // LL_TIM_SLAVEMODE_TRIGGER
	st,trigger-selection = <0x00>; // ITR0 = TIM1

	pwm8:mcpwm {
		compatible = "st,stm32-mcpwm";
		period = <PWM_KHZ(20)>;
		status = "okay";
		#pwm-cells = <2>;
	};
};
