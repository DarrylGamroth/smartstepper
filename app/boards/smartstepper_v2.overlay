/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/dt-bindings/dma/stm32_dma.h>

// / {
// 		/* Current sampler config, ADC channels */
// 	/* FIXME: Add drv8328 driver */
// 	/* drv8328 needs function to wiggle SLEEP to reset an error */
// 	control {

// 		// ADC for current (A, B), bus voltage
// 		adc-channels = <&adc1 0xc>, <&adc1 0x3>, <&adc1 0xa>;

// 		amp1 {
// 			compatible = "ti,drv8328";

// 			/* If FAULT interrupt is used instead of BRKIN */
// 			/* Fault interrupt should turn off PWM */
// 			// fault-gpios = <&gpioi 4 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;

// 			sleep-gpios = <&gpiog 14 GPIO_ACTIVE_HIGH>;

// 			pwms = <&pwm1 1 PWM_POLARITY_NORMAL>,
// 				   <&pwm1 2 PWM_POLARITY_NORMAL>;
// 		};

// 		amp2 {
// 			compatible = "ti,drv8328";

// 			/* If FAULT interrupt is used instead of BRKIN */
// 			// fault-gpios = <&gpiob 15 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;

// 			sleep-gpios = <&gpiod 8 GPIO_ACTIVE_HIGH>;

// 			pwms = <&pwm8 1 PWM_POLARITY_NORMAL>,
// 				   <&pwm8 2 PWM_POLARITY_NORMAL>;
// 		};
// 	};
// };

/ {
	user_parameters: user_parameters {
		compatible = "rubus,user-parameters";
		nominal_voltage-mv = <24000>;
		pwm-frequency-hz = <20000>;
		control-loop-frequency-hz = <20000>;
		current-loop-bandwidth-hz = <150>;
		offset-pole-hz = <300>;
		align-current-ma = <100>;
		align-duration-ms = <100>;
		brake-current-ma = <1000>;
		max-modulation-index-mpu = <570>;  /* 0.57 = sqrt(3)/2/sqrt(2), max for SVPWM linear region */
		roverl-est-current-ma = <67>;   /* 10-20% of rated (0.67A motor) */
		roverl-est-freq-hz = <100>;     /* Increase if motor twitches */
		roverl-est-settling-ms = <50>;  /* PI settling before measurement */
		roverl-est-duration-ms = <5000>;
		rs-est-current-ma = <67>;       /* Same as RoverL */
		rs-est-rampup-ms = <1000>;      /* Ramp to avoid transients */
		rs-est-duration-ms = <1000>;    /* ~31 time constants at 5Hz filter BW */
	};

	vbus_sense: vbus_sense {
		compatible = "rubus,vbus-sense";
		channel = <0>;
		vref-mv = <3000>;
		output-ohms = <10000>;
		full-ohms = <(191000 + 10000)>;
	};

	current_sense: current_sense {
		compatible = "rubus,current-sense";
		channels = <1>, <2>;
		current-sense-resistor-uohms = <10000>;
		current-sense-gain = <50>;
		vref-mv = <3000>;
	};

	motor_parameters: motor_parameters {
		compatible = "rubus,motor-parameters";
		inductance-d-uh = <3400>;
		inductance-q-uh = <3400>;
		resistance-mohms = <5600>;
		flux_linkage_mvphz = <15000>;
		pole-pairs = <50>;
		max-current-ma = <3000>;
		inertia-mgcm2 = <9000>;
		max-speed-hz = <400>;
	};

	angle_observer: angle_observer {
		compatible = "rubus,angle-observer";
		/* Observer bandwidth in Hz (position tracking) */
		bandwidth-hz = <200>;
	};

	fault_detection: fault_detection {
		compatible = "rubus,fault-detection";
		/* Consecutive encoder read failures before triggering fault */
		encoder-fault-threshold = <100>;
		/* Overcurrent threshold in milliamps (typically 120% of max) */
		overcurrent-threshold-ma = <3600>;  /* 120% of 3A max current */
	};
};

/ {
	model = "Smart Stepper Controller V2";
	compatible = "rubus,smartstepper_v2";

	chosen {
		zephyr,console = &usart1;
		zephyr,shell-uart = &usart1;
	};

	aliases {
		encoder1 = &aeat9955;
	};

	photo_interruptor_enable {
		compatible = "rubus,app-gpio";
		gpios = <&gpioe 1 GPIO_ACTIVE_HIGH>;
		status = "okay";
	};

	trig {
		compatible = "rubus,app-gpio";
		gpios = <&gpiob 9 GPIO_ACTIVE_HIGH>;
		status = "okay";
	};
};

// / {
// 	fstab {
// 		compatible = "zephyr,fstab";
// 		lfs1: lfs1 {
// 			compatible = "zephyr,fstab,littlefs";
// 			read-size = <32>;
// 			prog-size = <32>;
// 			cache-size = <256>;
// 			lookahead-size = <64>;
// 			block-cycles = <512>;
// 			partition = <&filesystem>;
// 			mount-point = "/lfs1";
// 		};
// 	};
// };

&usart1 {
	status = "okay";
};

&spi2 {
	fifo-enable;
	status = "okay";
};

&spi3 {
	fifo-enable;
	status = "okay";

	aeat9955: aeat9955@0 {
		compatible = "brcm,aeat-9955";
		reg = <0>;
		spi-max-frequency = <DT_FREQ_M(4)>;
		status = "okay";
	};
};

// Timer 2 is used for input capture of clock generator and photo-interrupter
&timers2 {
	compatible = "rubus,stm32-timers";
	st,prescaler = <0>;
	status = "okay";
	st,master-mode;
	st,countermode = <STM32_TIM_COUNTERMODE_UP>;

	triggers: triggers {
		compatible = "st,stm32-timer-ic";
		pinctrl-0 = <&tim2_ch1_pa0 &tim2_ch2_pb3>;
		pinctrl-names = "default";
		status = "okay";
	};
};

// TIM1 is master for TIM3 and TIM8 synchronization
&timers1 {
	compatible = "rubus,stm32-timers";
	st,prescaler = <0>;
	status = "okay";
	st,countermode = <STM32_TIM_COUNTERMODE_CENTER_UP_DOWN>;
	st,master-mode;
	st,master-mode-selection = <0x10>; // LL_TIM_TRGO_ENABLE - sync TIM3 and TIM8

	pwm1:mcpwm {
		period = <PWM_KHZ(20)>;
		status = "okay";
		#pwm-cells = <2>;
	};
};

// TIM3 is slave of TIM1
&timers3 {
	compatible = "rubus,stm32-timers";
	st,prescaler = <0>;
	status = "okay";
	st,countermode = <STM32_TIM_COUNTERMODE_UP>;
	st,slave-mode;
	st,slave-mode-selection = <0x6>; // LL_TIM_SLAVEMODE_TRIGGER
	st,trigger-selection = <0x00>; // ITR0 = TIM1

	pwm3:mcpwm {
		compatible = "st,stm32-mcpwm";
		period = <PWM_KHZ(20)>;
		status = "okay";
		#pwm-cells = <2>;
	};
};

// TIM8 is slave of TIM1
&timers8 {
	compatible = "rubus,stm32-timers";
	st,prescaler = <0>;
	status = "okay";
	st,countermode = <STM32_TIM_COUNTERMODE_CENTER_UP_DOWN>;
	st,slave-mode;
	st,slave-mode-selection = <0x6>; // LL_TIM_SLAVEMODE_TRIGGER
	st,trigger-selection = <0x00>; // ITR0 = TIM1

	pwm8:mcpwm {
		compatible = "st,stm32-mcpwm";
		period = <PWM_KHZ(20)>;
		status = "okay";
		#pwm-cells = <2>;
	};
};

&adc1 {
	compatible = "st,stm32-adc-injected";
	status = "okay";
	st,adc-trigger-source = "tim1_cc4";
};
