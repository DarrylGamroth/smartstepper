/*
 * Copyright (c) 2025 Rubus Technologies Inc.
 * SPDX-License-Identifier: Apache-2.0
 */

/dts-v1/;
#include <st/f4/stm32f407Xe.dtsi>
#include <st/f4/stm32f407i(e-g)tx-pinctrl.dtsi>
#include <zephyr/dt-bindings/input/input-event-codes.h>
#include <zephyr/dt-bindings/timer/stm32-timer.h>
#include <zephyr/dt-bindings/pwm/pwm.h>
#include <dt-bindings/pwm/stm32-mcpwm.h>

/ {
	model = "Smart Stepper Controller";
	compatible = "rubus,smartstepper";

	chosen {
		zephyr,sram = &sram0;
		zephyr,flash = &flash0;
		zephyr,ccm = &ccm0;
		// zephyr,dtcm = &ccm0;
		zephyr,canbus = &can1;
		zephyr,code-partition = &slot0_partition;
		zephyr,settings-partition = &settings_partition;
	};

	gpio_keys {
		compatible = "gpio-keys";
		user_button: button {
			label = "User";
			gpios = <&gpiod 9 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
			zephyr,code = <INPUT_KEY_0>;
		};
	};

	aliases {
		watchdog0 = &iwdg;
		sw0 = &user_button;
		encoder0 = &mt6835;
		die-temp0 = &die_temp;
		volt-sensor0 = &vref;
		gate-driver-a = &drv8328_a;
		gate-driver-b = &drv8328_b;		
	};

	vbus {
		compatible = "voltage-divider";
		io-channels = <&adc3 10>;
		output-ohms = <10000>;
		full-ohms = <(191000 + 10000)>;
	};

	drv8328_a: drv8328_a {
		compatible = "ti,drv8328";
		status = "okay";
		
		mode = "3x";
		
		pwms = <&pwm1 1 (PWM_POLARITY_NORMAL | STM32_PWM_OC_MODE_PWM1)>,
		       <&pwm1 2 (PWM_POLARITY_NORMAL | STM32_PWM_OC_MODE_PWM1)>;
		
		inl-gpios = <&gpioe 8 GPIO_ACTIVE_HIGH>,
		            <&gpiob 0 GPIO_ACTIVE_HIGH>;
		
		sleep-gpios = <&gpiog 14 GPIO_ACTIVE_HIGH>;
	};
	
	drv8328_b: drv8328_b {
		compatible = "ti,drv8328";
		status = "okay";
		
		mode = "3x";
		
		pwms = <&pwm8 1 (PWM_POLARITY_NORMAL | STM32_PWM_OC_MODE_PWM1)>,
		       <&pwm8 2 (PWM_POLARITY_NORMAL | STM32_PWM_OC_MODE_PWM1)>;
		
		inl-gpios = <&gpioh 13 GPIO_ACTIVE_HIGH>,
		            <&gpioh 14 GPIO_ACTIVE_HIGH>;
		
		sleep-gpios = <&gpiod 8 GPIO_ACTIVE_HIGH>;
	};
};

&clk_lsi {
	status = "okay";
};

&clk_hsi {
	status = "okay";
};

&clk_hse {
	clock-frequency = <DT_FREQ_M(25)>;
	hse-bypass;
	status = "disabled";
};

// &pll {
// 	div-m = <25>;
// 	mul-n = <336>;
// 	div-p = <2>;
// 	div-q = <7>;
// 	clocks = <&clk_hse>;
// 	status = "okay";
// };

&pll {
	div-m = <16>;
	mul-n = <336>;
	div-p = <2>;
	div-q = <7>;
	clocks = <&clk_hsi>;
	status = "okay";
};

&plli2s {
	mul-n = <100>;
	div-r = <2>;
	status = "okay";
};

&rcc {
	clocks = <&pll>;
	clock-frequency = <DT_FREQ_M(168)>;
	ahb-prescaler = <1>;
	apb1-prescaler = <4>;
	apb2-prescaler = <2>;
};

&rtc {
	clocks = <&rcc STM32_CLOCK(APB1, 28)>,
		 <&rcc STM32_SRC_LSI RTC_SEL(2)>;
	status = "okay";
};

&iwdg {
	status = "okay";
};

&rng {
	status = "okay";
};

/* See reference manual (RM0385):
 *   0b10: HSE oscillator clock selected
 */
 #define MCO2_SEL_HSE 2

&mco2 {
	clocks = <&rcc STM32_SRC_HSE MCO2_SEL(MCO2_SEL_HSE)>;
	prescaler = <MCO2_PRE(MCO_PRE_DIV_1)>;
	pinctrl-0 = <&rcc_mco_2_pc9>;
	pinctrl-names = "default";
	status = "okay";
};

&dma1 {
	status = "okay";
};

&dma2 {
	status = "okay";
};

&mac {
	status = "okay";
	pinctrl-0 = <&eth_rxd0_pc4
		     &eth_rxd1_pc5
		     &eth_ref_clk_pa1
		     &eth_crs_dv_pa7
		     &eth_tx_en_pb11
		     &eth_txd0_pb12
		     &eth_txd1_pb13>;
	pinctrl-names = "default";
	phy-connection-type = "rmii";
	phy-handle = <&eth_phy>;
};

&mdio {
	status = "okay";
	pinctrl-0 = <&eth_mdio_pa2 &eth_mdc_pc1>;
	pinctrl-names = "default";

	eth_phy: ethernet-phy@0 {
		status = "okay";
		compatible = "ti,dp83825";
		reg = <0>;
		reset-gpios = <&gpiob 15 GPIO_ACTIVE_LOW>;
		int-gpios = <&gpiob 14 GPIO_ACTIVE_LOW>;
		ti,interface-type = "rmii-25MHz";
	};
};

&i2c1 {
	pinctrl-0 = <&i2c1_scl_pb8 &i2c1_sda_pb9>;
	pinctrl-names = "default";
	clock-frequency = <I2C_BITRATE_FAST>;
	status = "disabled";
};

&i2c3 {
	pinctrl-0 = <&i2c3_scl_ph7 &i2c3_sda_ph8>;
	pinctrl-names = "default";
	status = "okay";
	clock-frequency = <I2C_BITRATE_FAST>;

	tmp1075: tmp1075@48 {
		compatible = "ti,tmp1075";
		reg = <0x48>;
		conversion-rate = <220000>;
		consecutive-fault-measurements = <4>;
		status = "okay";
	};

	eeprom: eeprom@50 {
		compatible = "st,m24c16", "st,m24xxx", "atmel,at24";
		reg = <0x50>;
		size = <DT_SIZE_K(2)>;
		pagesize = <16>;
		address-width = <8>;
		timeout = <5>;
		status = "okay";

		partitions {
			compatible = "fixed-partitions";
			#address-cells = <1>;
			#size-cells = <1>;

			/* Reserve 1KB for motor parameter settings */
			settings_partition: partition@0 {
				label = "settings_storage";
				reg = <0x0000 0x0400>;  /* 1KB at start of EEPROM */
			};

			/* Remaining 1KB available for calibration data, logs, etc. */
			user_data: partition@400 {
				label = "user_data";
				reg = <0x0400 0x0400>;  /* 1KB remaining */
			};
		};
	};

};

&usart1 {
	pinctrl-0 = <&usart1_tx_pb6 &usart1_rx_pb7>;
	pinctrl-names = "default";
	current-speed = <115200>;
	status = "disabled";
};

&spi1 {
	pinctrl-0 = <&spi1_sck_pb3 &spi1_miso_pb4 &spi1_mosi_pb5>;
	pinctrl-names = "default";
	cs-gpios = <&gpioa 4 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
	status = "okay";

	dmas = <&dma2 3 5 (STM32_DMA_PERIPH_TX | STM32_DMA_MEM_8BITS)>,
		<&dma2 3 0 (STM32_DMA_PERIPH_RX | STM32_DMA_MEM_8BITS)>;

	dma-names = "tx", "rx";

	w25q128: w25q128@0 {
		compatible ="jedec,spi-nor";
		size = <DT_SIZE_M(128)>;
		reg = <0>;
		spi-max-frequency = <DT_FREQ_M(50)>;
		status = "okay";
		jedec-id = [ef 40 18];

		partitions {
			compatible = "fixed-partitions";
			#address-cells = < 1 >;
			#size-cells = < 1 >;

			filesystem: partition@0 {
				label = "filesystem";
				reg=< 0x0 DT_SIZE_M(16) >;
			};
		};
	};
};

&spi2 {
	pinctrl-0 = <&spi2_sck_pi1 &spi2_miso_pi2 &spi2_mosi_pi3 &spi2_nss_pi0>;
	pinctrl-names = "default";
	// cs-gpios = <&gpioi 0 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
	status = "okay";

	mt6835: mt6835@0 {
		compatible = "magntek,mt6835";
		reg = <0>;
		spi-max-frequency = <DT_FREQ_M(12)>;
		cal-en-gpios = <&gpiog 13 GPIO_ACTIVE_HIGH>;
		status = "okay";
	};
};

&spi3 {
	pinctrl-0 = <&spi3_sck_pc10 &spi3_miso_pc11 &spi3_mosi_pc12 &spi3_nss_pa15>;
	pinctrl-names = "default";
	// cs-gpios = <&gpioa 15 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
	status = "disabled";
};

&can1 {
	pinctrl-0 = <&can1_rx_pb8 &can1_tx_pb9>;
	pinctrl-names = "default";
	status = "disabled";
};

zephyr_udc0: &usbotg_fs {
	pinctrl-0 = <&usb_otg_fs_dm_pa11 &usb_otg_fs_dp_pa12>;
	pinctrl-names = "default";
	status = "disabled";
};

&flash0 {
	partitions {
		compatible = "fixed-partitions";
		#address-cells = <1>;
		#size-cells = <1>;

		boot_partition: partition@0 {
			label = "mcuboot";
			reg = <0x00000000 DT_SIZE_K(34)>;
			read-only;
		};

		slot0_partition: partition@8800 {
			label = "image-0";
			reg = <0x00008800 DT_SIZE_K(240)>;
		};

		slot1_partition: partition@44800 {
			label = "image-1";
			reg = <0x00044800 DT_SIZE_K(238)>;
		};
	};
};

&timers1 {
	compatible = "rubus,stm32-timers";

	pwm1:mcpwm {
		compatible = "st,stm32-mcpwm";
		// pinctrl-0 = <&tim1_ch1_pa8 &tim1_ch1n_pe8 &tim1_ch2_pa9 &tim1_ch2n_pb0 &tim1_bkin_pe15>;
		pinctrl-0 = <&tim1_ch1_pa8 &tim1_ch2_pa9 &tim1_bkin_pe15>;
		pinctrl-names = "default";
		st,break-enable;
		st,break-polarity = "low";
		st,dead-time = <0>;
		status = "disabled";
		#pwm-cells = <2>;
	};
};

&timers8 {
	compatible = "rubus,stm32-timers";

	pwm8:mcpwm {
		compatible = "st,stm32-mcpwm";
		// pinctrl-0 = <&tim8_ch1_pc6 &tim8_ch1n_ph13 &tim8_ch2_pc7 &tim8_ch2n_ph14 &tim8_bkin_pi4>;
		pinctrl-0 = <&tim8_ch1_pc6 &tim8_ch2_pc7 &tim8_bkin_pi4>;
		pinctrl-names = "default";
		st,break-enable;
		st,break-polarity = "low";
		st,dead-time = <0>;
		status = "disabled";
		#pwm-cells = <2>;
	};
};

// &timers4 {
// 	status = "okay";

// 	pwm4: pwm {
// 		status = "disabled";
// 		pinctrl-0 = <&tim4_ch1_pd12 &tim4_ch2_pd13 &tim4_ch3_pd14 &tim4_ch4_pd15>;
// 		pinctrl-names = "default";
// 	};
// };

/* Enable pull-ups on BKIN pins */
&pinctrl {
    /omit-if-no-ref/ tim1_bkin_pe15: tim1_bkin_pe15 {
        bias-pull-up;
    };
	/omit-if-no-ref/ tim8_bkin_pi4: tim8_bkin_pi4 {
		bias-pull-up;
	};
};

&adc1 {
	pinctrl-0 = <&adc1_in3_pa3 &adc1_in12_pc2 &adc1_in10_pc0>;
	pinctrl-names = "default";
	st,adc-clock-source = "SYNC";
	st,adc-prescaler = <2>;
	status = "okay";

	vref-mv = <3000>;

	#address-cells = <1>;
	#size-cells = <0>;

	/* I_SENSE_A */
	channel@3 {
		reg = <3>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,resolution = <12>;
	};

	/* I_SENSE_B */
	channel@c {
		reg = <12>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,resolution = <12>;
	};

	/* VINSENSE */
	channel@a {
		reg = <10>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,resolution = <12>;
	};
};

&adc3 {
	compatible = "st,stm32f4-adc", "st,stm32-adc";
	st,adc-clock-source = "SYNC";
	st,adc-prescaler = <2>;
	status = "okay";

	vref-mv = <3000>;

	#address-cells = <1>;
	#size-cells = <0>;

	channel@a {
		reg = <10>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,resolution = <12>;
	};	
};
