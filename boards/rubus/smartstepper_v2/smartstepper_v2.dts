/*
 * Copyright (c) 2025 Rubus Technologies Inc.
 * SPDX-License-Identifier: Apache-2.0
 */

/dts-v1/;
#include <st/h7/stm32h743Xi.dtsi>
#include <st/h7/stm32h743iikx-pinctrl.dtsi>
#include <zephyr/dt-bindings/input/input-event-codes.h>
#include <zephyr/dt-bindings/timer/stm32-timer.h>
#include <zephyr/dt-bindings/pwm/pwm.h>
#include <dt-bindings/pwm/stm32-mcpwm.h>

/ {
	model = "Smart Stepper Controller V2";
	compatible = "rubus,smartstepper_v2";

	chosen {
		zephyr,sram = &sram0;
		zephyr,flash = &flash0;
		zephyr,canbus = &fdcan1;
		zephyr,itcm = &itcm;
		zephyr,dtcm = &dtcm;
		zephyr,code-partition = &slot0_partition;
		zephyr,settings-partition = &settings_partition;
	};

	gpio_keys {
		compatible = "gpio-keys";
		user_button: button {
			label = "User";
			gpios = <&gpiod 9 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
			zephyr,code = <INPUT_KEY_0>;
		};
	};

	aliases {
		watchdog0 = &iwdg;
		sw0 = &user_button;
		encoder0 = &mt6835;
		die-temp0 = &die_temp;
		volt-sensor0 = &vref;
		gate-driver-a = &drv8328_a;
		gate-driver-b = &drv8328_b;		
	};

	vbus {
		compatible = "voltage-divider";
		io-channels = <&adc3 10>;
		output-ohms = <10000>;
		full-ohms = <(191000 + 10000)>;
	};

	drv8328_a: drv8328_a {
		compatible = "ti,drv8328";
		status = "okay";
		
		mode = "3x";
		
		pwms = <&pwm1 1 (PWM_POLARITY_NORMAL | STM32_PWM_OC_MODE_PWM1)>,
		       <&pwm1 2 (PWM_POLARITY_NORMAL | STM32_PWM_OC_MODE_PWM1)>;
		
		inl-gpios = <&gpioe 8 GPIO_ACTIVE_HIGH>,
		            <&gpiob 0 GPIO_ACTIVE_HIGH>;
		
		sleep-gpios = <&gpiog 14 GPIO_ACTIVE_HIGH>;
	};
	
	drv8328_b: drv8328_b {
		compatible = "ti,drv8328";
		status = "okay";
		
		mode = "3x";
		
		pwms = <&pwm8 1 (PWM_POLARITY_NORMAL | STM32_PWM_OC_MODE_PWM1)>,
		       <&pwm8 2 (PWM_POLARITY_NORMAL | STM32_PWM_OC_MODE_PWM1)>;
		
		inl-gpios = <&gpioh 13 GPIO_ACTIVE_HIGH>,
		            <&gpioh 14 GPIO_ACTIVE_HIGH>;
		
		sleep-gpios = <&gpiod 8 GPIO_ACTIVE_HIGH>;
	};
};

&clk_lsi {
	status = "okay";
};

&clk_hsi {
	status = "disabled";
};

&clk_hse {
	clock-frequency = <DT_FREQ_M(25)>;
	hse-bypass;
	status = "okay";
};

&clk_hsi48 {
	status = "okay";
};

&pll {
	div-m = <5>;
	mul-n = <192>;
	div-p = <2>;
	div-q = <5>;    /* 192 MHz */
	div-r = <2>;
	clocks = <&clk_hse>;
	status = "okay";
};

&pll2 {
	div-m = <5>;
	mul-n = <48>;
	div-p = <2>;
	div-q = <3>; /* gives 80 MHz to the FDCAN */
	div-r = <2>;
	clocks = <&clk_hse>;
	status = "okay";
};

&rcc {
	clocks = <&pll>;
	clock-frequency = <DT_FREQ_M(480)>;
	d1cpre = <1>;
	hpre = <2>;
	d1ppre = <2>;
	d2ppre1 = <2>;
	d2ppre2 = <2>;
	d3ppre = <2>;
};

&pwr {
	power-supply = "ldo";
};

&rtc {
	clocks = <&rcc STM32_CLOCK(APB4, 16)>,
		 <&rcc STM32_SRC_LSI RTC_SEL(2)>;
	status = "okay";
};

&iwdg {
	status = "okay";
};

&rng {
	status = "okay";
};

&mco2 {
	clocks = <&rcc STM32_SRC_HSE MCO2_SEL(MCO2_SEL_HSE)>;
	prescaler = <MCO2_PRE(MCO_PRE_DIV_1)>;
	pinctrl-0 = <&rcc_mco_2_pc9>;
	pinctrl-names = "default";
	status = "okay";
};

&dmamux1 {
	status = "okay";
};

&dma1 {
	status = "okay";
};

&dma2 {
	status = "okay";
};

&mac {
	status = "okay";
	pinctrl-0 = <&eth_rxd0_pc4
		     &eth_rxd1_pc5
		     &eth_ref_clk_pa1
		     &eth_crs_dv_pa7
		     &eth_tx_en_pb11
		     &eth_txd0_pb12
		     &eth_txd1_pb13>;
	pinctrl-names = "default";
	phy-connection-type = "rmii";
	phy-handle = <&eth_phy>;
};

&mdio {
	status = "okay";
	pinctrl-0 = <&eth_mdio_pa2 &eth_mdc_pc1>;
	pinctrl-names = "default";

	eth_phy: ethernet-phy@0 {
		status = "okay";
		compatible = "ti,dp83825";
		reg = <0>;
		reset-gpios = <&gpiob 5 GPIO_ACTIVE_LOW>;
		int-gpios = <&gpiog 15 GPIO_ACTIVE_LOW>;
		ti,interface-type = "rmii-25MHz";
	};
};

&i2c1 {
	pinctrl-0 = <&i2c1_scl_pb8 &i2c1_sda_pb9>;
	pinctrl-names = "default";
	clock-frequency = <I2C_BITRATE_FAST>;
	status = "disabled";
};

&i2c3 {
	pinctrl-0 = <&i2c3_scl_ph7 &i2c3_sda_ph8>;
	pinctrl-names = "default";
	status = "okay";
	clock-frequency = <I2C_BITRATE_FAST>;

	tmp1075: tmp1075@48 {
		compatible = "ti,tmp1075";
		reg = <0x48>;
		conversion-rate = <220000>;
		consecutive-fault-measurements = <4>;
		status = "okay";
	};

	eeprom: eeprom@50 {
		compatible = "st,m24c16", "st,m24xxx", "atmel,at24";
		reg = <0x50>;
		size = <DT_SIZE_K(2)>;
		pagesize = <16>;
		address-width = <8>;
		timeout = <5>;
		status = "okay";

		partitions {
			compatible = "fixed-partitions";
			#address-cells = <1>;
			#size-cells = <1>;

			/* Reserve 1KB for motor parameter settings */
			settings_partition: partition@0 {
				label = "settings_storage";
				reg = <0x0000 0x0400>;  /* 1KB at start of EEPROM */
			};

			/* Remaining 1KB available for calibration data, logs, etc. */
			user_data: partition@400 {
				label = "user_data";
				reg = <0x0400 0x0400>;  /* 1KB remaining */
			};
		};
	};

};

&usart1 {
	pinctrl-0 = <&usart1_tx_pb6 &usart1_rx_pb7>;
	pinctrl-names = "default";
	current-speed = <115200>;
	status = "disabled";
};

&quadspi {
	pinctrl-0 = <&quadspi_bk1_io0_pd11 &quadspi_bk1_io1_pd12 &quadspi_bk1_io2_pe2
		     &quadspi_bk1_io3_pd13 &quadspi_clk_pf10 &quadspi_bk1_ncs_pg6>;
	pinctrl-names = "default";
	flash-id = <1>;
	status = "okay";

	w25q128: w25q128@0 {
		compatible = "st,stm32-qspi-nor";
		reg = <0>;
		size = <DT_SIZE_M(128)>;	/* 128 Mbits (16 MB) */
		jedec-id = [ef 40 18];
		qspi-max-frequency = <DT_FREQ_M(100)>;
		cs-high-time = <2>;
		status = "okay";
		spi-bus-width = <4>;
		writeoc = "PP_1_1_4";
		reset-cmd;
		reset-cmd-wait = <2000>;

		partitions {
			compatible = "fixed-partitions";
			#address-cells = < 1 >;
			#size-cells = < 1 >;

			filesystem: partition@0 {
				label = "filesystem";
				reg=< 0x0 DT_SIZE_M(16) >;
			};
		};
	};
};

&spi2 {
	pinctrl-0 = <&spi2_sck_pi1 &spi2_miso_pi2 &spi2_mosi_pi3 &spi2_nss_pi0>;
	pinctrl-names = "default";
	// cs-gpios = <&gpioi 0 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
	status = "okay";

	mt6835: mt6835@0 {
		compatible = "magntek,mt6835";
		reg = <0>;
		spi-max-frequency = <DT_FREQ_M(12)>;
		cal-en-gpios = <&gpiog 13 GPIO_ACTIVE_HIGH>;
		status = "okay";
	};
};

&spi3 {
	pinctrl-0 = <&spi3_sck_pc10 &spi3_miso_pc11 &spi3_mosi_pc12 &spi3_nss_pa15>;
	pinctrl-names = "default";
	// cs-gpios = <&gpioa 15 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
	status = "disabled";
};

&fdcan1 {
	clocks = <&rcc STM32_CLOCK(APB1_2, 8)>,
		 <&rcc STM32_SRC_PLL2_Q FDCAN_SEL(2)>;
	pinctrl-0 = <&fdcan1_rx_pb8 &fdcan1_tx_pb9>;
	pinctrl-names = "default";
	status = "disabled";
};

zephyr_udc0: &usbotg_fs {
	pinctrl-0 = <&usb_otg_hs_dm_pb14 &usb_otg_hs_dp_pb15>;
	pinctrl-names = "default";
	status = "disabled";
};

&flash0 {
	partitions {
		compatible = "fixed-partitions";
		#address-cells = <1>;
		#size-cells = <1>;

		boot_partition: partition@0 {
			label = "mcuboot";
			reg = <0x00000000 DT_SIZE_K(128)>;
			read-only;
		};

		slot0_partition: partition@20000 {
			label = "image-0";
			reg = <0x00020000 DT_SIZE_K(256)>;
		};

		slot1_partition: partition@60000 {
			label = "image-1";
			reg = <0x00060000 DT_SIZE_K(256)>;
		};
	};
};

&timers1 {
	compatible = "rubus,stm32-timers";

	pwm1:mcpwm {
		compatible = "st,stm32-mcpwm";
		// pinctrl-0 = <&tim1_ch1_pa8 &tim1_ch1n_pe8 &tim1_ch2_pa9 &tim1_ch2n_pb0 &tim1_bkin_pe15>;
		pinctrl-0 = <&tim1_ch1_pa8 &tim1_ch2_pa9 &tim1_bkin_pe15>;
		pinctrl-names = "default";
		st,break-enable;
		st,break-polarity = "low";
		st,dead-time = <0>;
		status = "disabled";
		#pwm-cells = <2>;
	};
};

&timers8 {
	compatible = "rubus,stm32-timers";

	pwm8:mcpwm {
		compatible = "st,stm32-mcpwm";
		// pinctrl-0 = <&tim8_ch1_pc6 &tim8_ch1n_ph13 &tim8_ch2_pc7 &tim8_ch2n_ph14 &tim8_bkin_pi4>;
		pinctrl-0 = <&tim8_ch1_pc6 &tim8_ch2_pc7 &tim8_bkin_pi4>;
		pinctrl-names = "default";
		st,break-enable;
		st,break-polarity = "low";
		st,dead-time = <0>;
		status = "disabled";
		#pwm-cells = <2>;
	};
};

// &timers4 {
// 	status = "okay";

// 	pwm4: pwm {
// 		status = "disabled";
// 		pinctrl-0 = <&tim4_ch1_pd12 &tim4_ch2_pd13 &tim4_ch3_pd14 &tim4_ch4_pd15>;
// 		pinctrl-names = "default";
// 	};
// };

/* Enable pull-ups on BKIN pins */
&pinctrl {
    /omit-if-no-ref/ tim1_bkin_pe15: tim1_bkin_pe15 {
        bias-pull-up;
    };
	/omit-if-no-ref/ tim8_bkin_pi4: tim8_bkin_pi4 {
		bias-pull-up;
	};
};

&adc1 {
	pinctrl-0 = <&adc1_inp15_pa3 &analog_pc2_c &adc1_inp10_pc0 >;
	pinctrl-names = "default";
	st,adc-clock-source = "SYNC";
	st,adc-prescaler = <4>;
	status = "okay";

    // clocks = <&rcc STM32_CLOCK(AHB1, 5)>,
    //          <&rcc STM32_SRC_PLL2_P ADC_SEL(2)>;
    // clock-names = "adcx", "adc_ker";
    // st,adc-clock-source = "ASYNC";	

	vref-mv = <3000>;

	#address-cells = <1>;
	#size-cells = <0>;

	/* I_SENSE_A */
	channel@f {
		reg = <15>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,resolution = <12>;
	};

	/* I_SENSE_B */
	channel@c {
		reg = <12>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,resolution = <12>;
	};

	/* VINSENSE */
	channel@a {
		reg = <10>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,resolution = <12>;
	};
};

&adc3 {
	st,adc-clock-source = "SYNC";
	st,adc-prescaler = <4>;
	status = "okay";

	vref-mv = <3000>;

	#address-cells = <1>;
	#size-cells = <0>;

	channel@a {
		reg = <10>;
		zephyr,gain = "ADC_GAIN_1";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,resolution = <12>;
	};
};

&die_temp {
	status = "okay";
};

&vref {
	status = "okay";
};
